# frozen_string_literal: true

require "spec_helper"

describe TimexDatalinkClient::Protocol7::Eeprom::Activity do
  let(:time) { Time.new(0, 1, 1, 1, 30, 0) }
  let(:messages) { [[0xb1]] }
  let(:random_speech) { false }

  let(:activity) do
    described_class.new(
      time:,
      messages:,
      random_speech:
    )
  end

  describe ".packets" do
    let(:activities) { [activity] }

    subject(:packets) { described_class.packets(activities) }

    it do
      should eq([0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x1e, 0x01, 0x0b, 0x00, 0x30, 0xb1, 0xff, 0x00, 0x00, 0x04])
    end

    context "with two activities" do
      let(:activity_2) do
        described_class.new(
          time: Time.new(0, 1, 1, 2, 30, 0),
          messages:,
          random_speech: true
        )
      end

      let(:activities) { [activity, activity_2] }

      it do
        should eq [
          0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x1e, 0x01, 0x10, 0x00, 0x02, 0x1e, 0x01, 0x15, 0x00, 0x30, 0xb1,
          0xff, 0x00, 0x00, 0x30, 0xb1, 0xff, 0x00, 0x00, 0x04
        ]
      end
    end
  end

  describe "#metadata_packet" do
    let(:activity_index) { 1 }

    subject(:metadata_packet) { activity.metadata_packet(activity_index) }

    it { should eq([0x01, 0x1e, 0x01, 0x0b, 0x00]) }

    context "when messages is [[0xb1, 0xb2]]" do
      let(:messages) { [[0xb1, 0xb2]] }

      it { should eq([0x01, 0x1e, 0x01, 0x0b, 0x00]) }
    end

    context "when messages is [[0xb1], [0xb2], [0xb3]]" do
      let(:messages) { [[0xb1], [0xb2], [0xb3]] }

      it { should eq([0x01, 0x1e, 0x03, 0x0b, 0x00]) }
    end

    context "when activity_index is 5" do
      let(:activity_index) { 5 }

      it { should eq([0x01, 0x1e, 0x01, 0x1f, 0x00]) }
    end
  end

  describe "#messages_packet" do
    subject(:messages_packet) { activity.messages_packet }

    it { should eq([0x30, 0xb1, 0xff, 0x00, 0x00]) }

    context "when messages is [[0xb1, 0xb2]]" do
      let(:messages) { [[0xb1, 0xb2]] }

      it { should eq([0x0c, 0xb1, 0xb2, 0xff, 0x00]) }
    end

    context "when messages is [[0xb1, 0xb2, 0xb3]]" do
      let(:messages) { [[0xb1, 0xb2, 0xb3]] }

      it { should eq([0x03, 0xb1, 0xb2, 0xb3, 0xff]) }
    end

    context "when messages is [[0xb1, 0xb2, 0xb3, 0xb4]]" do
      let(:messages) { [[0xb1, 0xb2, 0xb3, 0xb4]] }

      it { should eq([0x00, 0xb1, 0xb2, 0xb3, 0xb4, 0xc0, 0xff, 0x00, 0x00, 0x00]) }
    end

    context "when messages is [[0xb1, 0xb2, 0xb3, 0xb4, 0xb5]]" do
      let(:messages) { [[0xb1, 0xb2, 0xb3, 0xb4, 0xb5]] }

      it { should eq([0x00, 0xb1, 0xb2, 0xb3, 0xb4, 0x30, 0xb5, 0xff, 0x00, 0x00]) }
    end

    context "when messages is [[0xb1], [0xb2], [0xb3]]" do
      let(:messages) { [[0xb1], [0xb2], [0xb3]] }

      it { should eq([0x30, 0xb1, 0xfe, 0x00, 0x00, 0x30, 0xb2, 0xfe, 0x00, 0x00, 0x30, 0xb3, 0xff, 0x00, 0x00]) }
    end

    context "when messages is [[0xb1, 0xb2, 0xb3, 0xb4, 0xb5], [0xc1, 0xc2, 0xc3, 0xc4, 0xc5]]" do
      let(:messages) { [[0xb1, 0xb2, 0xb3, 0xb4, 0xb5], [0xc1, 0xc2, 0xc3, 0xc4, 0xc5]] }

      it do
        should eq [
          0x00, 0xb1, 0xb2, 0xb3, 0xb4, 0x30, 0xb5, 0xfe, 0x00, 0x00, 0x00, 0xc1, 0xc2, 0xc3, 0xc4, 0x30, 0xc5, 0xff,
          0x00, 0x00
        ]
      end
    end
  end

  describe "#random_speech" do
    subject(:random_speech_value) { activity.random_speech }

    it { should be_falsey }

    context "when random_speech is true" do
      let(:random_speech) { true }

      it { should be_truthy }
    end
  end
end
